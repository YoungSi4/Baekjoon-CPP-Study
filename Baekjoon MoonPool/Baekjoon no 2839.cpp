//// no 2839 설탕배달
//// 정답 ! , 설탕 봉지 수를 합한 값을 제외한 모든 cout을 지우면 정답이다.
//#include<iostream>
//#include<iomanip>
//using namespace std;
//
//int main() {
//	// 설탕 배달량 입력 (3 <= N <= 5000)
//	int N = 0;
//	cin >> N;
//	int i = 0;
//	// 1. -1 반환 규칙
//	
//	// 16 > 5*2 + 3*2 = 16 // 꼭 3의 배수 5의 배수가 아니어도.
//	// 조건에 만족하는 값이 있다. 로직 변경해야함.
//
//	// 반복 : 0 <= N - 5*i, i++ -> int i
//	// (N - 5*i) % 3 != 0 이라면 return -1
//
//	for (i; 5*i <= N ; i++) { // 최대 1000번 반복
//		if ((N - 5 * i) % 3 == 0) {
//			break;
//		}
//	}
//	if (5 * i > N){
//		cout << "-1";
//		return 0;
//	}
//
//	// 2. 최솟값 탐색
//	
//	// 2-1. 5키로 * 5키로 개수 + 3키로 * 3키로 개수 = 배달량
//	// 2-2. 5키로 개수 + 3키로 개수 = 최소화 (구하고 싶은 m)
//	
//	// 1 이 결정되는 순간,
//	// 2는 5키로의 개수를 최대에서 최소로 끌고가며 탐색
//	// 이 과정을 최적화 할 수 없을까?
//	// 우리는 개수가 "정수"이길 원한다
//	//
//	// 함수로 치면
//	// 3x + 5y = N		-- 1
//	// x + y = minimize	-- 2
//	
//	for (int num_5kg = N/5; 0 <= num_5kg / 5; num_5kg--) {
//		float num_3kg = (N - num_5kg * 5) / 3;
//		int num_3kg_int = num_3kg;
//		 cout << "num_3kg: " << num_3kg << endl;
//		 cout << "num_3kg int: " << num_3kg_int << endl;
//		 if (num_3kg_int * 3 + num_5kg * 5 == N) {
//			 cout << "5키로 봉지 수: " << num_5kg << endl;
//			 cout << "3키로 봉지 수: " << num_3kg_int << endl;
//			 cout << num_5kg + num_3kg_int;
//			 return 0;
//		}
//	}
//	// 1 함수는 N이 입력되며 결정된다.
//	// 우리는 1과 2의 교점 중
//	// y값이 가장 큰 교점을 원하고
//	// 이 교점의 합이 우리가 찾는 답이다.
//	// 
//	// x = 0 일 때 함수 1의 y값에 함수 2를 접하고
//	// 그 상태에서 각 교점이 정수가 될 때까지
//	// x를 늘려간다.
//	// x <= (N - 5y)/3 까지
//	// 
//	// p.s.
//	// 이러면 (min, 0) 이 정답인 케이스가
//	// 굉장히 오래 걸린다.
//	// 이걸 어떻게 보완해야할까?
//	// 
//	// 1안.
//	// 3 <= N <= 5000 구간에서
//	// 정수인 교점의 최솟값 분포를 확인? > 어케함 이걸...
//	//
//
//	return 0;
//}